//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本:4.0.30319.42000
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------

namespace AHeadLib.Net.Properties {
    using System;
    
    
    /// <summary>
    ///   一个强类型的资源类，用于查找本地化的字符串等。
    /// </summary>
    // 此类是由 StronglyTypedResourceBuilder
    // 类通过类似于 ResGen 或 Visual Studio 的工具自动生成的。
    // 若要添加或移除成员，请编辑 .ResX 文件，然后重新运行 ResGen
    // (以 /str 作为命令选项)，或重新生成 VS 项目。
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   返回此类使用的缓存的 ResourceManager 实例。
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("AHeadLib.Net.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   重写当前线程的 CurrentUICulture 属性，对
        ///   使用此强类型资源类的所有资源查找执行重写。
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   查找类似 ; generated by tools
        ///; AHeadLib.Net
        ///; https://github.com/bodong1987/AHeadLib.Net
        ///; Powered by bodong
        ///
        ///.DATA
        ///    ${EXTERNDEF_POINTERS}
        ///
        ///.CODE
        ///
        ///${FUNCTIONS}
        ///
        ///END
        /// 的本地化字符串。
        /// </summary>
        internal static string Asm_x64 {
            get {
                return ResourceManager.GetString("Asm_x64", resourceCulture);
            }
        }
        
        /// <summary>
        ///   查找类似 ; generated by tools
        ///; AHeadLib.Net
        ///; https://github.com/bodong1987/AHeadLib.Net
        ///; Powered by bodong
        ///
        ///.MODEL FLAT
        ///
        ///.DATA
        ///    ${EXTERNDEF_POINTERS}
        ///
        ///.CODE
        ///
        ///${FUNCTIONS}
        ///
        ///END
        /// 的本地化字符串。
        /// </summary>
        internal static string Asm_x86 {
            get {
                return ResourceManager.GetString("Asm_x86", resourceCulture);
            }
        }
        
        /// <summary>
        ///   查找类似 // implement by user
        ///#include &quot;MemoryPatchConfig.h&quot;
        ///#include &quot;resource.h&quot;
        ///#include &lt;cassert&gt;
        ///#include &lt;string&gt;
        ///
        ///extern &quot;C&quot;
        ///{
        ///    static void __ApplyResourceBasedPatches()
        ///    {
        ///        auto configs = LoadConfigurations(IDR_TXT2);
        ///
        ///        if (!configs.empty())
        ///        {
        ///            PatchMemoryWithConfig(configs);
        ///        }
        ///    }
        ///
        ///    static void __ApplyFileBasedPatches()
        ///    {
        ///        auto configs = LoadFileConfigurations();
        ///
        ///        if (!configs.empty())
        ///        {
        ///            PatchM [字符串的其余部分被截断]&quot;; 的本地化字符串。
        /// </summary>
        internal static string BuiltinImplementations {
            get {
                return ResourceManager.GetString("BuiltinImplementations", resourceCulture);
            }
        }
        
        /// <summary>
        ///   查找类似 // generated by tools
        ///// AHeadLib.Net
        ///// https://github.com/bodong1987/AHeadLib.Net
        ///// Powered by bodong
        ///
        ///#include &lt;windows.h&gt;
        ///
        ///#if defined(_WIN64) || defined(_X64) || defined(WIN64) || defined( __LP64__ )
        ///#define __X64_BUILD__ 1
        ///#else
        ///#define __X64_BUILD__ 0
        ///#endif
        ///
        ///// checked get function in native dll
        ///static void* __CheckedGetFunction(HMODULE module, const char* methodName)
        ///{
        ///    void* Result = GetProcAddress(module, methodName);
        ///
        ///    if (Result == NULL)
        ///    {
        ///        char szMessage[2 [字符串的其余部分被截断]&quot;; 的本地化字符串。
        /// </summary>
        internal static string CppHelper {
            get {
                return ResourceManager.GetString("CppHelper", resourceCulture);
            }
        }
        
        /// <summary>
        ///   查找类似 // generated by tools
        ///// AHeadLib.Net
        ///// https://github.com/bodong1987/AHeadLib.Net
        ///// Powered by bodong
        ///
        ///#include &lt;windows.h&gt;
        ///
        ///extern void __CheckedLoad();
        ///extern bool __ApplyBuiltinPatches();
        ///extern void __ExecuteUserCutomCodes();
        ///
        ///BOOL WINAPI DllMain(
        ///    HINSTANCE hinstDLL,  // handle to DLL module
        ///    DWORD fdwReason,     // reason for calling function
        ///    LPVOID lpvReserved)  // reserved
        ///{
        ///    // Perform actions based on the reason for calling.
        ///    switch (fdwReason)
        ///    {
        ///    case  [字符串的其余部分被截断]&quot;; 的本地化字符串。
        /// </summary>
        internal static string DllMain {
            get {
                return ResourceManager.GetString("DllMain", resourceCulture);
            }
        }
        
        /// <summary>
        ///   查找类似 #include &quot;MemoryPatchConfig.h&quot;
        ///#include &lt;cassert&gt;
        ///#include &lt;string&gt;
        ///#include &quot;MiniTools.h&quot;
        ///
        ///template &lt;typename TCharType&gt;
        ///inline bool IsTrimable(TCharType ch)
        ///{
        ///    return ch == &apos; &apos; || ch == &apos;\t&apos; || ch == &apos;\n&apos; || ch == &apos;\r&apos;;
        ///}
        ///
        ///inline static int CompareN(const char* first, const char* second, std::size_t n)
        ///{
        ///    return strncmp(first, second, n);
        ///}
        ///
        ///inline static bool StartWith(const std::string&amp; str, const std::string&amp; start)
        ///{
        ///    return str.size() &gt;= start.size() &amp;&amp; CompareN(str.c_str() [字符串的其余部分被截断]&quot;; 的本地化字符串。
        /// </summary>
        internal static string MemoryPatchConfig_cpp {
            get {
                return ResourceManager.GetString("MemoryPatchConfig_cpp", resourceCulture);
            }
        }
        
        /// <summary>
        ///   查找类似 #pragma once
        ///
        ///#ifndef  __cplusplus
        ///#error &quot;this header i created for C++ only.&quot;
        ///#endif
        ///
        ///#include &lt;windows.h&gt;
        ///
        ///#include &lt;vector&gt;
        ///#include &lt;string&gt;
        ///
        ///struct MemoryPatchConfig
        ///{
        ///    std::string ModuleName;
        ///    std::string SegmentName;
        ///    std::vector&lt;BYTE&gt; Signature;
        ///    std::vector&lt;BYTE&gt; NewBytes;
        ///
        ///    void Reset()
        ///    {
        ///        ModuleName.clear();
        ///        SegmentName.clear();
        ///        Signature.clear();
        ///        NewBytes.clear();
        ///    }
        ///
        ///    bool IsValid() const
        ///    {
        ///        return ! [字符串的其余部分被截断]&quot;; 的本地化字符串。
        /// </summary>
        internal static string MemoryPatchConfig_h {
            get {
                return ResourceManager.GetString("MemoryPatchConfig_h", resourceCulture);
            }
        }
        
        /// <summary>
        ///   查找类似 #include &quot;MiniTools.h&quot;
        ///#include &lt;algorithm&gt;
        ///#include &lt;cassert&gt;
        ///
        ///G_BEGIN_DECLS
        ///
        ///bool ReplaceMemory(void* dest, const void* source, int length)
        ///{
        ///    void* TargetAddress = dest;
        ///
        ///    DWORD oldProtect;
        ///    if (!VirtualProtect(TargetAddress, length, PAGE_EXECUTE_READWRITE, &amp;oldProtect))
        ///    {
        ///        MessageBox(0, TEXT(&quot;Failed to obtain write permission for target address&quot;), TEXT(&quot;Error&quot;), 0);
        ///
        ///        return false;
        ///    }
        ///
        ///    memcpy(TargetAddress, source, length);
        ///
        ///    if (!VirtualProtect(T [字符串的其余部分被截断]&quot;; 的本地化字符串。
        /// </summary>
        internal static string MiniTools_cpp {
            get {
                return ResourceManager.GetString("MiniTools_cpp", resourceCulture);
            }
        }
        
        /// <summary>
        ///   查找类似 #pragma once
        ///
        ///#include &lt;windows.h&gt;
        ///#include &lt;Psapi.h&gt;
        ///
        ///#ifdef  __cplusplus
        ///
        ///#ifndef G_BEGIN_DECLS
        ///# define G_BEGIN_DECLS  extern &quot;C&quot; {
        ///#endif
        ///
        ///#ifndef G_END_DECLS
        ///# define G_END_DECLS    }
        ///#endif
        ///
        ///#else
        ///
        ///#ifndef G_BEGIN_DECLS
        ///# define G_BEGIN_DECLS
        ///#endif
        ///
        ///#ifndef G_END_DECLS
        ///# define G_END_DECLS
        ///#endif
        ///
        ///#endif
        ///
        ///
        ///G_BEGIN_DECLS
        ///bool ReplaceMemory(void* dest, const void* source, int length);
        ///bool FindModuleSection(HMODULE module, const char* segmentName, void** outSectionStart, L [字符串的其余部分被截断]&quot;; 的本地化字符串。
        /// </summary>
        internal static string MiniTools_h {
            get {
                return ResourceManager.GetString("MiniTools_h", resourceCulture);
            }
        }
        
        /// <summary>
        ///   查找类似 ; auto patch ${LIB_NAME}.dll&apos;s segments, use this format:
        ///;
        ///; use ; start a comment line
        ///;library : dll name with .dll extension or 0, 0 is the main module
        ///;segenemnt : segment name, eg: .text|.data
        ///;signature : hex byte value sequence, splitted by space
        ///;newCodes : hex byte value sequence, splitted by space
        ///
        ///; for example:
        ///;library    : 0
        ///;segment    : .text
        ///;signature  : 0x1D 0x2D 0x3D
        ///;newCodes   : 0x55 0x6B 0x7D
        ///
        ///; for example2 : 
        ///;library    : proxy.dll
        ///;segment    : .text
        ///;signature   [字符串的其余部分被截断]&quot;; 的本地化字符串。
        /// </summary>
        internal static string patch {
            get {
                return ResourceManager.GetString("patch", resourceCulture);
            }
        }
        
        /// <summary>
        ///   查找类似 //{{NO_DEPENDENCIES}}
        ///// Microsoft Visual C++ generated file
        ///// for ${LIB_NAME} use
        /////
        ///#define IDR_TXT2                        102
        ///
        ///// Next default values for new objects
        ///// 
        ///#ifdef APSTUDIO_INVOKED
        ///#ifndef APSTUDIO_READONLY_SYMBOLS
        ///#define _APS_NEXT_RESOURCE_VALUE        103
        ///#define _APS_NEXT_COMMAND_VALUE         40001
        ///#define _APS_NEXT_CONTROL_VALUE         1001
        ///#define _APS_NEXT_SYMED_VALUE           101
        ///#endif
        ///#endif
        /// 的本地化字符串。
        /// </summary>
        internal static string resource {
            get {
                return ResourceManager.GetString("resource", resourceCulture);
            }
        }
        
        /// <summary>
        ///   查找类似 // Microsoft Visual C++ generated resource script.
        /////
        ///#include &quot;resource.h&quot;
        ///
        ///#define APSTUDIO_READONLY_SYMBOLS
        ////////////////////////////////////////////////////////////////////////////////
        /////
        ///// Generated from the TEXTINCLUDE 2 resource.
        /////
        ///#include &quot;winres.h&quot;
        ///
        ////////////////////////////////////////////////////////////////////////////////
        ///#undef APSTUDIO_READONLY_SYMBOLS
        ///
        ////////////////////////////////////////////////////////////////////////////////
        ///// 中文(简体，中国) resources
        ///
        ///#if !defined(AFX_RE [字符串的其余部分被截断]&quot;; 的本地化字符串。
        /// </summary>
        internal static string resource_rc {
            get {
                return ResourceManager.GetString("resource_rc", resourceCulture);
            }
        }
        
        /// <summary>
        ///   查找 System.Byte[] 类型的本地化资源。
        /// </summary>
        internal static byte[] solution {
            get {
                object obj = ResourceManager.GetObject("solution", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        /// <summary>
        ///   查找类似 // implement by user
        ///#include &quot;MemoryPatchConfig.h&quot;
        ///#include &lt;cassert&gt;
        ///
        ///extern &quot;C&quot;
        ///{
        ///    // fill original library path here
        ///    // use absolute file path
        ///    bool GetOrignalLibraryPath(TCHAR* bufferPtr, int bufferLength, const TCHAR* libName)
        ///    {
        ///        assert(bufferPtr != nullptr);
        ///        assert(libName != nullptr);
        ///
        ///        // By default, the path of the original Library is considered to be the system directory. 
        ///        // If you need another path, be sure to modify the code here and re [字符串的其余部分被截断]&quot;; 的本地化字符串。
        /// </summary>
        internal static string UserImplementations {
            get {
                return ResourceManager.GetString("UserImplementations", resourceCulture);
            }
        }
        
        /// <summary>
        ///   查找 System.Byte[] 类型的本地化资源。
        /// </summary>
        internal static byte[] vcxprojTemplate {
            get {
                object obj = ResourceManager.GetObject("vcxprojTemplate", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        /// <summary>
        ///   查找 System.Byte[] 类型的本地化资源。
        /// </summary>
        internal static byte[] vcxprojTemplate_filters {
            get {
                object obj = ResourceManager.GetObject("vcxprojTemplate_filters", resourceCulture);
                return ((byte[])(obj));
            }
        }
    }
}
